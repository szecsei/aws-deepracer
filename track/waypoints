import numpy as np
import matplotlib.pyplot as plt 
import math

#create list of waypoints
def createWaypoints():
            
            #self.waypoints = vertices = np.zeros((30, 2))
            waypoints = vertices = np.zeros((30, 2))

            #self.road_width = 0.44
            road_width = 0.44
            
            vertices[0][0] = 1.5;     vertices[0][1] = 0.58;
            vertices[1][0] = 5.5;     vertices[1][1] = 0.58;
            vertices[2][0] = 5.6;     vertices[2][1] = 0.6;
            vertices[3][0] = 5.7;     vertices[3][1] = 0.65;
            vertices[4][0] = 5.8;     vertices[4][1] = 0.7;
            vertices[5][0] = 5.9;     vertices[5][1] = 0.8;
            vertices[6][0] = 6.0;     vertices[6][1] = 0.9;
            vertices[7][0] = 6.08;    vertices[7][1] = 1.1;
            vertices[8][0] = 6.1;     vertices[8][1] = 1.2;
            vertices[9][0] = 6.1;     vertices[9][1] = 1.3;
            vertices[10][0] = 6.1;    vertices[10][1] = 1.4;
            vertices[11][0] = 6.07;   vertices[11][1] = 1.5;
            vertices[12][0] = 6.05;   vertices[12][1] = 1.6;
            vertices[13][0] = 6;      vertices[13][1] = 1.7;
            vertices[14][0] = 5.9;    vertices[14][1] = 1.8;
            vertices[15][0] = 5.75;   vertices[15][1] = 1.9;
            vertices[16][0] = 5.6;    vertices[16][1] = 2.0;
            vertices[17][0] = 4.2;    vertices[17][1] = 2.02;
            vertices[18][0] = 4;      vertices[18][1] = 2.1;
            vertices[19][0] = 2.6;    vertices[19][1] = 3.92;
            vertices[20][0] = 2.4;    vertices[20][1] = 4;
            vertices[21][0] = 1.2;    vertices[21][1] = 3.95;
            vertices[22][0] = 1.1;    vertices[22][1] = 3.92;
            vertices[23][0] = 1;      vertices[23][1] = 3.88;
            vertices[24][0] = 0.8;    vertices[24][1] = 3.72;
            vertices[25][0] = 0.6;    vertices[25][1] = 3.4;
            vertices[26][0] = 0.58;   vertices[26][1] = 3.3;
            vertices[27][0] = 0.57;   vertices[27][1] = 3.2;
            vertices[28][0] = 1;      vertices[28][1] = 1;
            vertices[29][0] = 1.25;   vertices[29][1] = 0.7;
            
            return waypoints
            
           
def createGraph(points1, points2):
            
            # x-axis values
            x1 = []
            y1 = []
            for i in range(0, len(points1)):
                        x1.append(points1[i][0])
                        y1.append(points1[i][1])              
            
            x2 = []
            y2 = []
            for i in range(0, len(points2)):
                        x2.append(points2[i][0])
                        y2.append(points2[i][1])            
              
            # plotting points as a scatter plot
            plt.scatter(x1, y1, label= "Waypoint", color= "green",  marker= "*", s=30) 
            plt.scatter(x2, y2, label= "Function", color= "red",  marker= "*", s=30) 
            
            # x-axis label 
            plt.xlabel('x - axis') 
            # frequency label 
            plt.ylabel('y - axis') 
            # plot title 
            plt.title('DeepRacer Track Waypoints') 
            # showing legend 
            plt.legend() 
              
            # function to show the plot 
            plt.show()     

#let's define all of the pieces of the track, starting with the first, long linear function
#these functions will return n evenly-placed intermediate points along the curve
#based on the parameter t, which ranges from 0 to 1

#this function will give the desired number of intermediate points
#along the linear segment connecting (start_x, start_y) and (stop_x, stop_y)

#this function will create intermediate waypoints for the following track segments:
#f1, f3, f5, f7, f9
def linearFunctions(start_x, start_y, stop_x, stop_y, n):
            listOfPoints = []
            counter = 0
            while counter <= n:
                        newPoint = [start_x * (1 - counter / n) + stop_x * (counter / n), start_y * (1 - counter / n) + stop_y * (counter / n) ]
                        listOfPoints.append(newPoint)
                        counter = counter + 1
            return listOfPoints


#def this function will parameterize the semi-circle given the starting and stopping
#points, the angle (in degrees), and the number of intermediate points, n
#this function uses the law of cosines: a^2 + b^2 - 2abcos(theta) = c^2
#we calculate c^2 from the starting and stopping coordinates, and then determine
#a using the formula
def generalCurve(start_x, start_y, stop_x, stop_y, theta, n, center_below, sweep_clockwise,hack):
            
            #convert theta from degrees to radians
            theta_radians = math.radians(theta)
            
            #determine a
            #step 1: compute c using the distance formula
            c = ((start_x - stop_x)**2 + (start_y - stop_y)**2)**0.5
            
            #i will also need the midpoint for later on in the calculation of the center
            mid_x = (start_x + stop_x)/2
            mid_y = (start_y + stop_y)/2
            
            #compute radius using the law of cosines:
            radius = c / (2 * (1 - math.cos(theta_radians)))**.5
            
            if center_below == True:
                        mySign = 1
                        startAngle = 0
            else:
                        mySign = -1
                        startAngle = math.pi
            if hack == True:
                        startAngle = theta_radians - math.pi
                        
            if sweep_clockwise == True:
                        clockwiseSign = 1
            else:
                        clockwiseSign = -1
            if hack == True:
                        clockwiseSign = -1

                        
            
            #determine the coordinates of the center of the circle
            center_x = mid_x + mySign * ((radius**2 - (c/2)**2)**0.5) * (start_y - stop_y)/c
            center_y = mid_y + mySign * ((radius**2 - (c/2)**2)**0.5) * (stop_x - start_x)/c
            
            print(radius, mid_x, mid_y, c, center_x, center_y)
            
            #next, determine the equation of the 
            listOfPoints = []
            counter = 0
            
            
            sectorSize = theta_radians / n
            while counter <= n:

                        newPoint = [radius * math.sin(startAngle + clockwiseSign * counter * sectorSize) + center_x, radius * math.cos(startAngle + clockwiseSign * counter * sectorSize) + center_y]

                        listOfPoints.append(newPoint)
                        counter = counter + 1
            print(listOfPoints)
            return listOfPoints 

def createCombinedPlot(n):
            points1 = createWaypoints()
            #generalCurve(start_x, start_y, stop_x, stop_y, theta, n, center_below, sweep_clockwise, hack):
            curve1 = generalCurve(5.5, .58, 5.6, 2.0, 180, n, False, False, False)
            curve2 = generalCurve(4.2, 2.02, 4, 2.1, 51, n, False, True, False)
            curve3 = generalCurve(2.6, 3.92, 2.4, 4, 53, n, True, True, False)
            curve4 = generalCurve(1.2, 3.95, .57, 3.2, 100, n, True, False, False)
            curve5 = generalCurve(1, 1, 1.5, .58, 78, n, True, True, True)
            
            #linearFunctions(start_x, start_y, stop_x, stop_y, n):
            straight1 = linearFunctions(1.5, .58, 5.5, .58, 12)
            straight2 = linearFunctions(5.6, 2.0, 4.2, 2.02, 8)
            straight3 = linearFunctions(4, 2.1, 2.6, 3.92, 12)
            straight4 = linearFunctions(2.4, 4, 1.2, 3.95, 8)
            straight5 = linearFunctions(.57, 3.2, 1, 1, 12)
                        
            points2 = curve1 + curve2 + curve3 + curve4 + curve5 + straight1 + straight2 + straight3 + straight4 + straight5
            createGraph(points1, points2)
